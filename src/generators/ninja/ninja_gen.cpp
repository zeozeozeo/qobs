#include "ninja_gen.hpp"
#include "../../utils.hpp" // For utils::replace, utils::is_windows
#include <stdlib.h>
#include <sstream> // Required for std::ostringstream

#include <spdlog/spdlog.h>
using namespace spdlog;

const std::filesystem::path QOBS_FILES_DIR = "QobsFiles";

void NinjaGenerator::write(std::string_view code) {
    m_code += code;
}

void NinjaGenerator::writeln(std::string_view code) {
    write(code);
    write("\n");
}

inline std::string escape_path(const std::filesystem::path& path) {
    std::string str = path.string();
    utils::replace_in_place(str, "$", "$$");
    utils::replace_in_place(str, ":", "$:");
    utils::replace_in_place(str, " ", "$ ");
    return str;
}

void NinjaGenerator::generate(
    const Manifest& manifest,
    const std::vector<BuildFile>& files,
    std::string_view output_name_sv,
    std::string_view compiler,
    const std::map<std::string, BuiltDependencyInfo>& built_dependencies,
    const std::filesystem::path& current_package_root,
    std::string_view build_profile_sv) { // Added build_profile
    
    m_code.clear();
    std::string output_name = std::string(output_name_sv);
    std::string build_profile = std::string(build_profile_sv);
    if (build_profile.empty()) { // Default profile if not specified
        build_profile = "debug"; 
        debug("Build profile not specified, defaulting to 'debug'.");
    }


    writeln("# This file is automatically @generated by Qobs: DO NOT EDIT!");
    writeln("ninja_required_version = 1.11 # For depfile $out.d syntax and deps = gcc"); // Updated version
    writeln("");

    // --- Variables ---
    writeln(fmt::format("user_cflags = {}", manifest.target().cflags()));
    writeln(fmt::format("user_ldflags = {}", manifest.target().ldflags()));
    writeln(fmt::format("cc = {}", compiler));
    writeln("");

    // --- Profile specific flags ---
    std::string profile_cflags_val;
    std::string profile_ldflags_val;
    if (build_profile == "debug") {
        profile_cflags_val = "-g";
        // No specific ldflags for debug by default
    } else if (build_profile == "release") {
        profile_cflags_val = "-O2 -DNDEBUG";
        profile_ldflags_val = "-s"; // Strip symbols
    } else {
        warn("Unknown build profile '{}'. No profile-specific flags will be applied.", build_profile);
    }
    writeln(fmt::format("profile_cflags = {}", profile_cflags_val));
    writeln(fmt::format("profile_ldflags = {}", profile_ldflags_val));
    writeln("");

    // --- CFLAGS and LDFLAGS from dependencies ---
    std::ostringstream dep_cflags_builder;
    std::ostringstream dep_ldflags_builder;
    for (const auto& [dep_name, dep_info] : built_dependencies) {
        if (dep_info.manifest.package().type() == "lib") {
            // Public include directories
            for (const auto& relative_include_dir : dep_info.manifest.package().public_include_dirs()) {
                std::filesystem::path absolute_include_path = dep_info.src_path / relative_include_dir;
                dep_cflags_builder << " -I" << escape_path(std::filesystem::weakly_canonical(absolute_include_path));
            }
            // Public cflags from dependency
            if (!dep_info.manifest.target().public_cflags().empty()) {
                dep_cflags_builder << " " << dep_info.manifest.target().public_cflags();
            }
            // Public ldflags from dependency
            if (!dep_info.manifest.target().public_ldflags().empty()) {
                dep_ldflags_builder << " " << dep_info.manifest.target().public_ldflags();
            }
        }
    }
    writeln(fmt::format("dep_cflags ={}", dep_cflags_builder.str()));
    writeln(fmt::format("dep_ldflags ={}", dep_ldflags_builder.str()));
    writeln("");

    // --- Final effective flags ---
    writeln("final_cflags = $user_cflags $profile_cflags $dep_cflags");
    // For linking, order might matter: user flags, then profile, then dependency link flags, then dependency artifacts.
    writeln("final_ldflags = $user_ldflags $profile_ldflags $dep_ldflags");
    writeln("");

    // --- Archiver command ---
    // TODO: Use utils::find_archiver() or a more robust detection/configuration method
#ifdef QOBS_IS_WINDOWS
    // Assuming usage of MSVC's lib.exe. MinGW/Clang on Windows use 'ar'.
    // This needs to be more robust, perhaps based on the compiler detected.
    // For now, a simple conditional. If compiler is gcc/clang on windows, this is wrong.
    if (std::string(compiler).find("cl.exe") != std::string::npos || std::string(compiler).find("cl") != std::string::npos) {
        writeln("ar_cmd = lib.exe");
        writeln("ar_flags = /NOLOGO"); // Typical flags for lib.exe
        writeln("ar_out_prefix = /OUT:");
    } else { // Assume MinGW or similar that uses 'ar'
        writeln("ar_cmd = ar");
        writeln("ar_flags = rcs");
        writeln("ar_out_prefix = "); 
    }
#else
    writeln("ar_cmd = ar");
    writeln("ar_flags = rcs");
    writeln("ar_out_prefix = "); // No prefix for output like /OUT: for ar
#endif
    writeln("");

    // --- Rules ---
    writeln("# Rules");
    writeln("rule cc");
    // TODO: Add MSVC /showIncludes handling for depfiles. Requires parsing stdout.
    writeln("  command = $cc $final_cflags -MMD -MF $out.d -c $in -o $out");
    writeln("  depfile = $out.d");
    writeln("  deps = gcc"); // Tells Ninja how to parse the .d file
    writeln(fmt::format("  description = CC $out (for {} profile {})", manifest.package().name(), build_profile));

    writeln("rule link");
    // Build list of libraries to link (dependency artifacts)
    std::ostringstream libs_to_link_builder;
    for (const auto& [dep_name, dep_info] : built_dependencies) {
        libs_to_link_builder << " " << escape_path(dep_info.artifact_path);
    }
    writeln(fmt::format("  command = $cc $final_ldflags -o $out $in{}", libs_to_link_builder.str()));
    writeln(fmt::format("  description = LINK $out (for {} profile {})", manifest.package().name(), build_profile));
    
    writeln("rule ar");
#ifdef QOBS_IS_WINDOWS
    // More robustly handle ar vs lib.exe based on $ar_cmd
    // if $ar_cmd is lib.exe, command = $ar_cmd $ar_flags $ar_out_prefix$out $in
    // if $ar_cmd is ar, command = $ar_cmd $ar_flags $out $in
    // Using a variable for the command structure itself might be too complex for Ninja directly.
    // A simpler way is to define two rules if they are too different or adjust $ar_flags and $ar_out_prefix.
    // The current ar_cmd, ar_flags, ar_out_prefix approach should work if $in is a list of files.
    writeln("  command = $ar_cmd $ar_flags $ar_out_prefix$out $in");
    warn_once("The archiver rule for Windows (lib.exe vs ar) is experimental. Verify compiler toolset.");
#else
    writeln("  command = $ar_cmd $ar_flags $out $in");
#endif
    writeln(fmt::format("  description = AR $out (for {} profile {})", manifest.package().name(), build_profile));
    writeln("");


    // --- Compile source files ---
    std::vector<std::string> object_file_paths;
    auto obj_dir_name = manifest.package().name() + ".dir";
    std::filesystem::path obj_root_dir = QOBS_FILES_DIR / obj_dir_name;

    auto get_obj_path = [&](const std::filesystem::path& src_file_path) {
        std::filesystem::path relative_src_path;
        if (src_file_path.is_absolute()) {
            auto rel = std::filesystem::relative(src_file_path, current_package_root);
            if (!rel.empty() && rel.native()[0] != '.') {
                 relative_src_path = rel;
            } else {
                 relative_src_path = src_file_path.filename();
                 warn("Source file {} is outside package root {}. Object file will be placed flat in obj_dir.", src_file_path.string(), current_package_root.string());
            }
        } else {
            relative_src_path = src_file_path;
        }
        // Ensure .obj is appended to the full path, not just filename
        return escape_path(obj_root_dir / (relative_src_path.string() + ".obj"));
    };

    writeln("\n# Compile source files");
    if (files.empty() && (manifest.package().type() == "app" || manifest.package().type() == "lib")) {
        // If a library has no sources, it might be header-only. We create a dummy object file
        // and a dummy archive to satisfy linking if other libraries depend on it.
        // For an app, no sources is an error or unusual.
        if (manifest.package().type() == "lib") {
            warn("No source files found for library {}. If it's not header-only, this is an issue. Creating dummy archive.", output_name);
            // Create a dummy source file and object path for the archive rule
            // This is a bit of a hack. A better way would be for 'ar' to create an empty archive.
            // However, 'ar' usually needs at least one object.
            // Alternative: Ninja 'phony' rule if the lib is truly header only and no artifact is needed.
            // But other libs might try to link it. So a dummy archive is safer.
             std::string dummy_obj_path = escape_path(obj_root_dir / "qobs_dummy_object.obj");
             writeln(fmt::format("# Dummy object for header-only library {}", output_name));
             // This requires a dummy cc rule that creates an empty .obj or a valid minimal .obj
             // For simplicity, we'll assume `ar` can create an archive from nothing or this rule is skipped if object_file_paths is empty by `ar`.
             // Most `ar` commands will error with no input. This needs more thought for true header-only.
             // For now, let's assume object_file_paths will be empty and the `ar` rule for $in might handle it or error.
             // A common pattern is to have one .cpp file that includes all headers to ensure they compile.
        } else { // app
             warn("No source files found for application {}. This will likely fail to link.", output_name);
        }
    }

    for (const auto& file : files) {
        std::string escaped_src_path = escape_path(file.path());
        std::string obj_path = get_obj_path(file.path());
        object_file_paths.push_back(obj_path);
        writeln(fmt::format("build {}: cc {}", obj_path, escaped_src_path));
    }
    writeln("");

    // --- Link or Archive ---
    if (manifest.package().type() == "app") {
        writeln(fmt::format("# Link the application: {}", output_name));
        write(fmt::format("build {}: link", escape_path(output_name)));
        for (const auto& obj_path : object_file_paths) {
            write(" ");
            write(obj_path);
        }
        writeln();
    } else if (manifest.package().type() == "lib") {
        writeln(fmt::format("# Archive the static library: {}", output_name));
        if (object_file_paths.empty()) {
             writeln(fmt::format("# No object files for library {}, archive will be empty or skipped.", output_name));
             // Create a phony rule for the output name to ensure it's a valid target if no objects.
             // This makes it "exist" for other parts of Ninja graph, but no actual archive is made.
             // This is suitable if a "library" artifact must be named but is header-only.
             // However, linkers will fail if they try to link an empty/phony archive.
             // A dummy archive (see above) is often preferred.
             // For now, if object_file_paths is empty, the build line below will be empty for $in.
             // `ar rcs libfoo.a` (with no objects) might create an empty archive or error.
             // `lib.exe /OUT:foo.lib` (with no objects) will error.
             // This path needs robust handling for header-only libraries.
        }
        write(fmt::format("build {}: ar", escape_path(output_name)));
        for (const auto& obj_path : object_file_paths) {
            write(" ");
            write(obj_path);
        }
        writeln();
    }

    writeln("\n# Default target");
    if (!files.empty() || manifest.package().type() != "lib" || !object_file_paths.empty()) {
        // Only make it default if there's something to build or it's an app
        writeln(fmt::format("default {}", escape_path(output_name)));
    } else if (manifest.package().type() == "lib" && files.empty()) {
        writeln(fmt::format("# Phony target for header-only library output name: {}", escape_path(output_name)));
        writeln(fmt::format("build {}: phony", escape_path(output_name)));
        writeln(fmt::format("default {}", escape_path(output_name)));

    }

    writeln("");
}

void NinjaGenerator::invoke(std::filesystem::path ninja_file_path) {
    auto build_dir = ninja_file_path.parent_path();
    info("invoking ninja in directory: {}", build_dir.string());
    
    std::string command = fmt::format("ninja -C \"{}\" -f \"{}\"", 
                                      build_dir.string(), 
                                      ninja_file_path.filename().string());
    trace("Executing: {}", command);

    int result = system(command.c_str());
    if (result != 0) {
        error("Ninja build failed with exit code: {}", result);
        throw std::runtime_error(fmt::format("Ninja build failed for {} with exit code {}", ninja_file_path.string(), result));
    }
}
